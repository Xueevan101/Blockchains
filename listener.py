# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PPbIm1eFRauxSiMprMaObG2QFnPZB_ro
"""

from web3 import Web3
from web3.providers.rpc import HTTPProvider
from web3.middleware import ExtraDataToPOAMiddleware  # Necessary for POA chains
from pathlib import Path
import json
from datetime import datetime
import pandas as pd


def scan_blocks(chain, start_block, end_block, contract_address, eventfile='deposit_logs.csv'):
    if chain == 'avax':
        api_url = f"https://api.avax-test.network/ext/bc/C/rpc"
    elif chain == 'bsc':
        api_url = f"https://data-seed-prebsc-1-s1.binance.org:8545/"
    else:
        raise ValueError("Invalid chain specified. Must be 'avax' or 'bsc'.")

    w3 = Web3(Web3.HTTPProvider(api_url))
    w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)

    DEPOSIT_ABI = json.loads("""
    [
        {
            "anonymous": false,
            "inputs": [
                { "indexed": true, "internalType": "address", "name": "token", "type": "address" },
                { "indexed": true, "internalType": "address", "name": "recipient", "type": "address" },
                { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
            ],
            "name": "Deposit",
            "type": "event"
        }
    ]""")

    contract = w3.eth.contract(address=contract_address, abi=DEPOSIT_ABI)

    if start_block == "latest":
        start_block = w3.eth.get_block_number()
    if end_block == "latest":
        end_block = w3.eth.get_block_number()

    if end_block < start_block:
        raise ValueError(f"end_block ({end_block}) must be >= start_block ({start_block})")

    print(f"Scanning blocks {start_block} - {end_block} on {chain}")

    logs = []
#create function where we create our dictionary of the 6 values we need to log for the logger
    def process_events(events):
        for event in events:
            logs.append({
                "chain": chain,
                "token": event.args.token,
                "recipient": event.args.recipient,
                "amount": str(event.args.amount),
                "transactionHash": event.transactionHash.hex(),
                "address": event.address
            })
#we start here, if the range of blocks is low
    if end_block - start_block < 30:
        event_filter = contract.events.Deposit.create_filter(
            from_block=start_block,
            to_block=end_block,
            argument_filters={}
        )
        events = event_filter.get_all_entries()  
        process_events(events)
    else:
        for block_num in range(start_block, end_block + 1):
            event_filter = contract.events.Deposit.create_filter(
                from_block=block_num,
                to_block=block_num,
                argument_filters={}
            )
            events = event_filter.get_all_entries()
            process_events(events)
#if logs exist, then create a dataframe of the logs and save them to csv, if not print nothing was found
    if logs:
        df = pd.DataFrame(logs)
        df.to_csv(eventfile, index=False)
        print(f"Saved {len(logs)} Deposit events to {eventfile}")
    else:
        print("No deposit event found in specified block range.")
