# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UBSRIMzyTUva4mOL4XpeSiTqCxWepjwV
"""

import random
import json
from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware
from web3.providers.rpc import HTTPProvider

#function from previous assignment
def connect_to_eth():
    url = "https://mainnet.infura.io/v3/bd562fa9921a4b1ba854b681adc30b5b"
    w3 = Web3(HTTPProvider(url))
    assert w3.is_connected(), f"Failed to connect to provider at {url}"
    return w3

#function from previous assignment
def connect_with_middleware(contract_json):
    with open(contract_json, "r") as f:
        d = json.load(f)
        d = d['bsc']
        address = d['address']
        abi = d['abi']

    url = "https://data-seed-prebsc-1-s1.binance.org:8545/"
    w3 = Web3(HTTPProvider(url))
    w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)
    assert w3.is_connected(), f"Failed to connect to BNB Testnet at {url}"

    contract = w3.eth.contract(address=Web3.to_checksum_address(address), abi=abi)
    return w3, contract

#takes an ethereum block to calculate the fees (gas prices) for that block for the transaction
def is_ordered_block(w3, block_num):
    block = w3.eth.get_block(block_num, full_transactions=True)
    base_fee = block.get('baseFeePerGas', None)
    txs = block.transactions
    priority_fees = []
    for tx in txs:
        tx_type = tx.get('type', '0x0')
        gas_price = tx.get('gasPrice')
#here we are calculating the fees. if the base_fee exists, subtract from the gas price to get priority fee
        if tx_type in (None, '0x0', 0):
            if base_fee is not None:
                priority_fee = gas_price - base_fee
            else:
                priority_fee = gas_price
#here, we have a type 2 transaction where if there is a gas price, use it to calculate prioirity fee. Else we use a formula for the max priority fee
        elif tx_type in ('0x2', 2):
            if gas_price is not None:
                priority_fee = gas_price - base_fee
            else:
                max_fee = tx.get('maxFeePerGas')
                max_priority = tx.get('maxPriorityFeePerGas')
                priority_fee = min(max_priority, max_fee - base_fee)
        else:
            return False

        priority_fees.append(priority_fee)

    ordered = all(priority_fees[i] >= priority_fees[i + 1] for i in range(len(priority_fees) - 1))
    return ordered


def get_contract_values(contract, admin_address, owner_address):
    """
    Takes a contract object, and two addresses (as strings) to check current on-chain values.
    """
    default_admin_role = int.to_bytes(0, 32, byteorder="big")
    onchain_root = contract.functions.merkleRoot().call()
    has_role = contract.functions.hasRole(default_admin_role, admin_address).call()
    prime = contract.functions.getPrimeByOwner(owner_address).call()
    return onchain_root, has_role, prime


if __name__ == "__main__":
    # These are addresses associated with the Merkle contract
    admin_address = "0xAC55e7d73A792fE1A9e051BDF4A010c33962809A"
    owner_address = "0x793A37a85964D96ACD6368777c7C7050F05b11dE"
    contract_file = "contract_info.json"

    eth_w3 = connect_to_eth()
    cont_w3, contract = connect_with_middleware(contract_file)

    latest_block = eth_w3.eth.get_block_number()
    london_hard_fork_block_num = 12965000
    assert latest_block > london_hard_fork_block_num, f"Error: the chain never got past the London Hard Fork"

    n = 5
    for _ in range(n):
        block_num = random.randint(1, latest_block)
        ordered = is_ordered_block(eth_w3, block_num)
        if ordered:
            print(f"Block {block_num} is ordered")
        else:
            print(f"Block {block_num} is not ordered")
